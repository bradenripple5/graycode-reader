<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Radial Binary Pattern</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      text-align: center;
      color: #333;
    }
    .container {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    canvas {
      display: block;
      margin: 20px auto;
      background: #eee;
      border: 1px solid #ddd;
    }
    .controls {
      margin: 20px 0;
      text-align: center;
    }
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin: 10px 5px 0 0;
    }
    button:hover {
      background: #0056b3;
    }
    .info {
      color: #666;
      font-size: 14px;
      margin-top: 10px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h1>Radial Binary Pattern</h1>

  <div class="container">
    <div class="controls">
      <label for="bandCount">Number of bands: <span id="bandCountVal">4</span></label>
      <input id="bandCount" type="range" min="1" max="12" value="4">
      <label for="circleSize">Circle radius: <span id="circleSizeVal">300</span>px</label>
      <input id="circleSize" type="range" min="10" max="1000" value="300">
      <label>
        <input id="invertBits" type="checkbox">
        Invert bits
      </label>
      <label>
        <input id="reverseBits" type="checkbox">
        Reverse bit order
      </label>
      <label for="centerGap">Center whitespace: <span id="centerGapVal">90</span>%</label>
      <input id="centerGap" type="range" min="0" max="90" value="90">
      <label for="angleOffset">Angle offset: <span id="angleOffsetVal">0</span>°</label>
      <input id="angleOffset" type="range" min="0" max="359" value="0">
      <label for="rotateSpeed">Rotation speed: <span id="rotateSpeedVal">30</span>°/s</label>
      <input id="rotateSpeed" type="range" min="1" max="30" value="30">
      <button id="rotateBtn">Start rotation</button>
      <button id="reloadBtn">Regenerate</button>
      <div class="info">Generated in the browser (Gray code)</div>
    </div>

    <canvas id="radialCanvas"></canvas>

    <div class="info">Rows (rings)</div>
    <textarea id="rowsOutput" readonly></textarea>

    <div class="info">Columns (angular positions)</div>
    <textarea id="colsOutput" readonly></textarea>

  </div>

  <script>
    const baseRingWidth = 25;

    function renderRadialPattern(data, canvas, centerGapPercent, angleOffsetDeg, radiusPx) {
      if (!data || data.length === 0) return;

      const ctx = canvas.getContext('2d');
      const numRings = data.length;
      const maxRadius = numRings * baseRingWidth;
      const scaledRadius = Math.max(1, radiusPx);
      const size = scaledRadius * 2 + 100;

      canvas.width = size;
      canvas.height = size;

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const gapRadius = (centerGapPercent / 100) * scaledRadius;
      const ringWidth = (scaledRadius - gapRadius) / numRings;
      const angleOffset = (angleOffsetDeg * Math.PI) / 180;

      ctx.fillStyle = '#EEEEEE';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let ringIdx = 0; ringIdx < numRings; ringIdx++) {
        const segments = data[ringIdx];
        const numSegments = segments.length;
        const innerRadius = gapRadius + ringIdx * ringWidth;
        const outerRadius = gapRadius + (ringIdx + 1) * ringWidth;

        for (let segIdx = 0; segIdx < numSegments; segIdx++) {
          const value = segments[segIdx];

          const startAngle = (segIdx / numSegments) * 2 * Math.PI + angleOffset;
          const endAngle = ((segIdx + 1) / numSegments) * 2 * Math.PI + angleOffset;

          ctx.fillStyle = value === 1 ? '#FFFFFF' : '#000';

          ctx.beginPath();
          ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle);
          ctx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
          ctx.closePath();
          ctx.fill();

          ctx.strokeStyle = '#CCCCCC';
          ctx.lineWidth = 0.5;
          ctx.stroke();
        }
      }

      if (centerGapPercent > 0) {
        const markerThickness = Math.max(2, ringWidth * 0.08);
        ctx.fillStyle = '#FF0000';
        drawRing(ctx, centerX, centerY, gapRadius, gapRadius + markerThickness);
        drawRing(ctx, centerX, centerY, gapRadius + numRings * ringWidth - markerThickness, gapRadius + numRings * ringWidth);
      }

      drawColumnLabels(
        ctx,
        centerX,
        centerY,
        gapRadius + numRings * ringWidth,
        ringWidth,
        data,
        angleOffset
      );
    }

    function drawRing(ctx, cx, cy, innerRadius, outerRadius) {
      ctx.beginPath();
      ctx.arc(cx, cy, outerRadius, 0, 2 * Math.PI);
      ctx.arc(cx, cy, innerRadius, 2 * Math.PI, 0, true);
      ctx.closePath();
      ctx.fill();
    }

    function columnValueFromRings(rings, colIndex) {
      const sections = rings.length;
      let value = 0;
      for (let ringIdx = 0; ringIdx < sections; ringIdx++) {
        const bit = rings[ringIdx][colIndex] ?? 0;
        value = (value << 1) | (bit & 1);
      }
      return value;
    }

    function drawColumnLabels(ctx, cx, cy, outerRadius, ringWidth, rings, angleOffset) {
      const columnCount = rings.length > 0 ? rings[0].length : 0;
      if (columnCount <= 0) return;
      const labelRadius = outerRadius + Math.max(12, ringWidth * 0.4);
      const arcPerColumn = (2 * Math.PI * labelRadius) / columnCount;

      ctx.save();
      ctx.fillStyle = '#222222';
      ctx.font = '12px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const maxLabel = String(Math.max(0, (1 << rings.length) - 1));
      const maxLabelWidth = ctx.measureText(maxLabel).width;
      const minSpacing = maxLabelWidth + 6;
      const step = Math.max(1, Math.ceil(minSpacing / arcPerColumn));

      for (let segIdx = 0; segIdx < columnCount; segIdx += step) {
        const angle = (segIdx / columnCount) * 2 * Math.PI + angleOffset;
        const x = cx + Math.cos(angle) * labelRadius;
        const y = cy + Math.sin(angle) * labelRadius;
        const value = columnValueFromRings(rings, segIdx);

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.fillText(String(value), 0, 0);
        ctx.restore();
      }

      ctx.restore();
    }

    function grayCode(value) {
      return value ^ (value >> 1);
    }

    function generateRings(sections, invert, reverse) {
      const columns = 1 << sections;
      const rings = Array.from({ length: sections }, () => []);
      for (let col = 0; col < columns; col++) {
        const code = grayCode(col);
        for (let bit = 0; bit < sections; bit++) {
          const ringIdx = bit;
          const bitIdx = reverse ? bit : (sections - 1 - bit);
          let value = (code >> bitIdx) & 1;
          if (invert) value = value ^ 1;
          rings[ringIdx].push(value);
        }
      }
      return rings;
    }

    function ringsToColumns(rings) {
      const ringCount = rings.length;
      if (ringCount === 0) return [];
      const cols = rings[0].length;
      const columns = [];
      for (let c = 0; c < cols; c++) {
        const col = [];
        for (let r = 0; r < ringCount; r++) {
          col.push(rings[r][c] ?? 0);
        }
        columns.push(col);
      }
      return columns;
    }

    function renderFromControls() {
      const canvas = document.getElementById('radialCanvas');
      const bandInput = document.getElementById('bandCount');
      const bandVal = document.getElementById('bandCountVal');
      const sizeInput = document.getElementById('circleSize');
      const sizeVal = document.getElementById('circleSizeVal');
      const invertInput = document.getElementById('invertBits');
      const reverseInput = document.getElementById('reverseBits');
      const gapInput = document.getElementById('centerGap');
      const gapVal = document.getElementById('centerGapVal');
      const angleInput = document.getElementById('angleOffset');
      const angleVal = document.getElementById('angleOffsetVal');
      const speedInput = document.getElementById('rotateSpeed');
      const speedVal = document.getElementById('rotateSpeedVal');
      const rowsOutput = document.getElementById('rowsOutput');
      const colsOutput = document.getElementById('colsOutput');

      const sections = parseInt(bandInput.value, 10);
      const defaultRadius = sections * baseRingWidth;
      const maxRadius = Math.max(defaultRadius * 10, 10);
      sizeInput.max = String(Math.round(maxRadius));
      if (sizeInput.value === "0") {
        sizeInput.value = "300";
      }

      const radiusPx = parseInt(sizeInput.value, 10);
      const invert = invertInput.checked;
      const reverse = reverseInput.checked;
      const gapPercent = parseInt(gapInput.value, 10);
      const angleOffset = autoRotate ? currentAngle : parseFloat(angleInput.value);
      if (!autoRotate) {
        currentAngle = angleOffset;
      }
      const displayAngle = ((angleOffset % 360) + 360) % 360;

      bandVal.textContent = sections;
      sizeVal.textContent = radiusPx;
      gapVal.textContent = gapPercent;
      angleVal.textContent = String(Math.round(displayAngle));
      speedVal.textContent = speedInput.value;

      const rings = generateRings(sections, invert, reverse);
      renderRadialPattern(rings, canvas, gapPercent, angleOffset, radiusPx);

      const rowsText = rings.map(row => row.join(',')).join('\n');
      const columns = ringsToColumns(rings);
      const colsText = columns.map(col => col.join(',')).join('\n');
      rowsOutput.value = rowsText;
      colsOutput.value = colsText;

    }

    let autoRotate = false;
    let lastFrameTime = 0;
    let currentAngle = 0;

    function stepRotation(timestamp) {
      if (!autoRotate) return;
      if (!lastFrameTime) lastFrameTime = timestamp;
      const deltaSec = (timestamp - lastFrameTime) / 1000;
      lastFrameTime = timestamp;

      const angleInput = document.getElementById('angleOffset');
      const speedInput = document.getElementById('rotateSpeed');
      const speed = parseFloat(speedInput.value);
      currentAngle += speed * deltaSec;
      const displayAngle = ((currentAngle % 360) + 360) % 360;
      angleInput.value = String(displayAngle);
      renderFromControls();
      requestAnimationFrame(stepRotation);
    }

    document.getElementById('bandCount').addEventListener('input', renderFromControls);
    document.getElementById('circleSize').addEventListener('input', renderFromControls);
    document.getElementById('invertBits').addEventListener('change', renderFromControls);
    document.getElementById('reverseBits').addEventListener('change', renderFromControls);
    document.getElementById('centerGap').addEventListener('input', renderFromControls);
    document.getElementById('angleOffset').addEventListener('input', renderFromControls);
    document.getElementById('rotateSpeed').addEventListener('input', renderFromControls);
    document.getElementById('reloadBtn').addEventListener('click', renderFromControls);
    document.getElementById('rotateBtn').addEventListener('click', () => {
      autoRotate = !autoRotate;
      const button = document.getElementById('rotateBtn');
      button.textContent = autoRotate ? 'Stop rotation' : 'Start rotation';
      if (autoRotate) {
        lastFrameTime = 0;
        requestAnimationFrame(stepRotation);
      }
    });
    window.onload = renderFromControls;
  </script>
</body>
</html>
